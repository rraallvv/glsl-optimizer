#include <metal_stdlib>
using namespace metal;
struct xlatMtlShaderInput {
  float4 xlv_TEXCOORD0;
};
struct xlatMtlShaderOutput {
  half4 _fragData [[color(0)]];
};
struct xlatMtlShaderUniform {
};
fragment xlatMtlShaderOutput xlatMtlMain (xlatMtlShaderInput _mtl_i [[stage_in]], constant xlatMtlShaderUniform& _mtl_u [[buffer(0)]])
{
  xlatMtlShaderOutput _mtl_o;
  half4 c_1;
  c_1 = half4(float4(0.0, 0.0, 0.0, 0.0));
  float tmpvar_2;
  if ((_mtl_i.xlv_TEXCOORD0.x > 0.5)) {
    tmpvar_2 = 0.9;
  } else {
    tmpvar_2 = 0.1;
  };
  c_1 = half4(float4(tmpvar_2));
  float4 tmpvar_3;
  if ((_mtl_i.xlv_TEXCOORD0.x > 0.5)) {
    tmpvar_3 = float4(0.9, 0.9, 0.9, 0.9);
  } else {
    tmpvar_3 = float4(0.1, 0.1, 0.1, 0.1);
  };
  half4 tmpvar_4;
  tmpvar_4 = ((half4)(float4(tmpvar_2) + tmpvar_3));
  c_1 = tmpvar_4;
  float3 tmpvar_5;
  if ((_mtl_i.xlv_TEXCOORD0.x > 0.5)) {
    tmpvar_5 = float3(0.9, 0.9, 0.9);
  } else {
    tmpvar_5 = float3(0.1, 0.1, 0.1);
  };
  c_1.xyz = (tmpvar_4.xyz + (half3)tmpvar_5);
  float2 tmpvar_6;
  if ((_mtl_i.xlv_TEXCOORD0.x > 0.5)) {
    tmpvar_6 = float2(0.9, 0.9);
  } else {
    tmpvar_6 = float2(0.1, 0.1);
  };
  c_1.xy = (c_1.xy + (half2)tmpvar_6);
  float tmpvar_7;
  tmpvar_7 = fract(_mtl_i.xlv_TEXCOORD0.x);
  float tmpvar_8;
  if (bool(tmpvar_7)) {
    tmpvar_8 = 0.9;
  } else {
    tmpvar_8 = 0.1;
  };
  c_1.x = (c_1.x + (half)tmpvar_8);
  _mtl_o._fragData = c_1;
  return _mtl_o;
}


// stats: 21 alu 0 tex 5 flow
// inputs: 1
//  #0: xlv_TEXCOORD0 (high float) 4x1 [-1]
