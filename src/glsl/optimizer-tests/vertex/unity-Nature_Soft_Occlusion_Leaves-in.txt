mat3 xll_constructMat3( mat4 m) {
  return mat3( vec3( m[0]), vec3( m[1]), vec3( m[2]));
}
struct v2f_vertex_lit {
    vec2 uv;
    vec4 diff;
    vec4 spec;
};
struct v2f_img {
    vec4 pos;
    vec2 uv;
};
struct appdata_img {
    vec4 vertex;
    vec2 texcoord;
};
struct SurfaceOutput {
    vec3 Albedo;
    vec3 Normal;
    vec3 Emission;
    float Specular;
    float Gloss;
    float Alpha;
};
struct appdata_full {
    vec4 vertex;
    vec4 tangent;
    vec3 normal;
    vec4 texcoord;
    vec4 texcoord1;
    vec4 color;
};
struct Input {
    vec2 uv_MainTex;
};
struct v2f_surf {
    vec4 pos;
    float fog;
    vec2 hip_pack0;
    vec3 normal;
    vec3 vlight;
    vec4 _ShadowCoord;
};
uniform vec4 _MainTex_ST;
uniform mat4 _Object2World;
uniform vec4 _ProjectionParams;
uniform vec4 _Scale;
uniform float _SquashAmount;
uniform vec4 _SquashPlaneNormal;
uniform mat4 _TerrainEngineBendTree;

uniform vec4 unity_4LightAtten0;
uniform vec4 unity_4LightPosX0;
uniform vec4 unity_4LightPosY0;
uniform vec4 unity_4LightPosZ0;
uniform vec3 unity_LightColor0;
uniform vec3 unity_LightColor1;
uniform vec3 unity_LightColor2;
uniform vec3 unity_LightColor3;
uniform vec4 unity_SHAb;
uniform vec4 unity_SHAg;
uniform vec4 unity_SHAr;
uniform vec4 unity_SHBb;
uniform vec4 unity_SHBg;
uniform vec4 unity_SHBr;
uniform vec4 unity_SHC;
uniform vec4 unity_Scale;
vec4 Squash( in vec4 pos );
void TerrainAnimateTree( inout vec4 pos, in float alpha );
void treevertex( inout appdata_full v );
vec3 ShadeSH9( in vec4 normal );
vec3 Shade4PointLights( in vec4 lightPosX, in vec4 lightPosY, in vec4 lightPosZ, in vec3 lightColor0, in vec3 lightColor1, in vec3 lightColor2, in vec3 lightColor3, in vec4 lightAttenSq, in vec3 pos, in vec3 normal );
void PositionFog( in vec4 v, out vec4 pos, out float fog );
vec4 ComputeScreenPos( in vec4 pos );
v2f_surf vert_surf( in appdata_full v );
vec4 Squash( in vec4 pos ) {
    vec3 projectedVertex;
    vec3 planePoint;
    vec3 planeNormal;
    projectedVertex = pos.xyz ;
    planePoint = vec3( 0.000000, _SquashPlaneNormal.w , 0.000000);
    planeNormal = _SquashPlaneNormal.xyz ;
    projectedVertex += (dot( planeNormal, (planePoint - vec3( pos))) * planeNormal);
    pos = vec4( mix( projectedVertex, pos.xyz , vec3( _SquashAmount)), 1.00000);
    return pos;
}
void TerrainAnimateTree( inout vec4 pos, in float alpha ) {
    vec3 bent;
    pos.xyz  *= _Scale.xyz ;
    bent = ( _TerrainEngineBendTree * vec4( pos.xyz , 0.000000) ).xyz ;
    pos.xyz  = mix( pos.xyz , bent, vec3( alpha));
    pos = Squash( pos);
}
void treevertex( inout appdata_full v ) {
    TerrainAnimateTree( v.vertex, v.color.w );
}
vec3 ShadeSH9( in vec4 normal ) {
    vec3 x1;
    vec4 vB;
    vec3 x2;
    float vC;
    vec3 x3;
    x1.x  = dot( unity_SHAr, normal);
    x1.y  = dot( unity_SHAg, normal);
    x1.z  = dot( unity_SHAb, normal);
    vB = (normal.xyzz  * normal.yzzx );
    x2.x  = dot( unity_SHBr, vB);
    x2.y  = dot( unity_SHBg, vB);
    x2.z  = dot( unity_SHBb, vB);
    vC = ((normal.x  * normal.x ) - (normal.y  * normal.y ));
    x3 = (unity_SHC.xyz  * vC);
    return ((x1 + x2) + x3);
}
vec3 Shade4PointLights( in vec4 lightPosX, in vec4 lightPosY, in vec4 lightPosZ, in vec3 lightColor0, in vec3 lightColor1, in vec3 lightColor2, in vec3 lightColor3, in vec4 lightAttenSq, in vec3 pos, in vec3 normal ) {
    vec4 toLightX;
    vec4 toLightY;
    vec4 toLightZ;
    vec4 lengthSq;
    vec4 ndotl;
    vec4 corr;
    vec4 atten;
    vec4 diff;
    vec3 col;
    toLightX = (lightPosX - pos.x );
    toLightY = (lightPosY - pos.y );
    toLightZ = (lightPosZ - pos.z );
    lengthSq = vec4( 0.000000);
    lengthSq += (toLightX * toLightX);
    lengthSq += (toLightY * toLightY);
    lengthSq += (toLightZ * toLightZ);
    ndotl = vec4( 0.000000);
    ndotl += (toLightX * normal.x );
    ndotl += (toLightY * normal.y );
    ndotl += (toLightZ * normal.z );
    corr = inversesqrt( lengthSq );
    ndotl = max( vec4( 0.000000, 0.000000, 0.000000, 0.000000), (ndotl * corr));
    atten = (1.00000 / (1.00000 + (lengthSq * lightAttenSq)));
    diff = (ndotl * atten);
    col = vec3( 0.000000);
    col += (lightColor0 * diff.x );
    col += (lightColor1 * diff.y );
    col += (lightColor2 * diff.z );
    col += (lightColor3 * diff.w );
    return col;
}
void PositionFog( in vec4 v, out vec4 pos, out float fog ) {
    pos = ( gl_ModelViewProjectionMatrix * v );
    fog = pos.z ;
}
vec4 ComputeScreenPos( in vec4 pos ) {
    vec4 o;
    o = (pos * 0.500000);
    o.xy  = (vec2( o.x , (o.y  * _ProjectionParams.x )) + o.w );
    o.zw  = pos.zw ;
    return o;
}
v2f_surf vert_surf( in appdata_full v ) {
    v2f_surf o;
    vec3 worldN;
    vec3 shlight;
    vec3 worldPos;
    treevertex( v);
    PositionFog( v.vertex, o.pos, o.fog);
    o.hip_pack0.xy  = ((v.texcoord.xy  * _MainTex_ST.xy ) + _MainTex_ST.zw );
    worldN = ( xll_constructMat3( _Object2World) * (v.normal * unity_Scale.w ) );
    o.normal = worldN;
    shlight = ShadeSH9( vec4( worldN, 1.00000));
    o.vlight = shlight;
    worldPos = ( _Object2World * v.vertex ).xyz ;
    o.vlight += Shade4PointLights( unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0, unity_LightColor0, unity_LightColor1, unity_LightColor2, unity_LightColor3, unity_4LightAtten0, worldPos, worldN);
    o._ShadowCoord = ComputeScreenPos( o.pos);
    return o;
}
attribute vec4 TANGENT;
varying vec4 xlv_FOG;
void main() {
    v2f_surf xl_retval;
    appdata_full xlt_v;
    xlt_v.vertex = vec4( gl_Vertex);
    xlt_v.tangent = vec4( TANGENT);
    xlt_v.normal = vec3( gl_Normal);
    xlt_v.texcoord = vec4( gl_MultiTexCoord0);
    xlt_v.texcoord1 = vec4( gl_MultiTexCoord1);
    xlt_v.color = vec4( gl_Color);
    xl_retval = vert_surf( xlt_v);
    gl_Position = vec4( xl_retval.pos);
    xlv_FOG = vec4( xl_retval.fog, 0.0, 0.0, 0.0);
    gl_TexCoord[0] = vec4( xl_retval.hip_pack0, 0.0, 0.0);
    gl_TexCoord[1] = vec4( xl_retval.normal, 0.0);
    gl_TexCoord[2] = vec4( xl_retval.vlight, 0.0);
    gl_TexCoord[3] = vec4( xl_retval._ShadowCoord);
}
